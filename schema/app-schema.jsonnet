// This provides schema governing command data objects as consumed by
// appfwk::Application (eg ddnode CLI).
//
// The schema is separated into levels with highest being most
// general.  Each level is described in terms of specific types with
// lower level types being described as an "any".  The levels are:
//
// command :: .id and .data, see cmd-schema.jsonnet.
//
// application :: ("app") schema applied to command.data based on
// value of command.id.  Application delegates most command.data to
// command handlers.
//
// handler :: basically the level of daq_process
//
// The appfwk::Application protects itself with an FSM which is
// generated by the "fsm" schema also provided here.

local moo = import "moo.jsonnet";
local re = moo.schema.re;
local ccm = import "ccm.jsonnet";
local cmdschema = import "cmd-schema.jsonnet";
local cn = ccm.commands.N;      // abbrev

local fsm = import "fsm.jsonnet";


function(schema) {
    local cmd = cmdschema(schema),
    name: "App",
    deps: [cmd],

    typeinst : schema.record("TypeName", fields=[
        schema.field("type", cmd.ident, doc="Type name"),
        schema.field("name", cmd.ident, doc="Instance name"),
    ], doc="Type/instance name pair for factory construction"),
    typeinsts : schema.sequence("TypeNames", self.typeinst),

    addrdat: schema.record("AddrDat", fields=[
        schema.field("tn", $.typeinst, doc="The addressed instance"),
        schema.field("data", cmd.data, doc="The associated data"),
    ], doc="Data addressed to a particular instance"),
    addrdats: schema.sequence("AddrDats", self.addrdat),

    // app-level interpretation of command data
    appcmd: schema.record("Addressed", fields = [
        schema.field("addrdats", $.addrdats, doc="The command data")
    ], doc="Addressed command data"),

    fsm: {                      // finite state machine description
        local rdy = fsm.state("Ready", "The process is a blank slate"),
        local ini = fsm.state("Initialized", "The process structure is constructed"),
        local cfg = fsm.state("Configured", "The process is configured"),
        local run = fsm.state("Running", "The process is operating"),

        tt: [                   // transition table
            fsm.trans(rdy, cn.Init, ini),
            fsm.trans(ini, cn.Conf, cfg),
            fsm.trans(cfg, cn.Start,run),
            fsm.trans(run, cn.Stop, cfg),
            fsm.trans(cfg, cn.Scrap,ini),
            fsm.trans(ini, cn.Fina, rdy),
        ],

        initial: self.tt[0].ini.name,
        states: fsm.states(self.tt),
        actions: fsm.actions(self.tt),
        events: fsm.events(self.tt),
    },

    // The FSM requires unique type for each FSM event.  These simply
    // encapsulate the command.  The application handler and command
    // handler will apply additional schema to the command.data.
    local events = [
        schema.record(n, fields=[
            schema.field("command", cmd.command, doc="The command"),
        ], doc="App FSM event '%s'"%n)
        for n in $.fsm.events],

    types: [cmd.data, //cmd.ident, cmd.data, cmd.command,
            $.typeinst, $.typeinsts,
            $.addrdat, $.addrdats, $.appcmd] + events,

}

/*
 * This file is 100% generated.  Any manual edits will likely be lost.
 *
 * This provides a full implementation of a command contract validator
 * plugin for {{model.meta.name}}.
 *
 * It validates a stream of commands to have expected order as
 * determined by a finite state machine.
 */
{% set ccclass = model.meta.name + "CommandContract" %}

#include "appfwk/CommandContract.hpp"
#include "appfwk/Issues.hpp"
#include <boost/msm/front/state_machine_def.hpp>
#include <boost/msm/back/state_machine.hpp>
#include <nlohmann/json.hpp>

#include "{{model.meta.incdir}}/{{model.meta.name}}Nljs{{model.meta.ext}}"

#include <nlohmann/json.hpp>

{% for dep in model.meta.deps %}
using namespace {{dep.ns}};
{% endfor %}
using namespace {{model.meta.ns}};

struct {{ccclass}} : public dunedaq::appfwk::CommandContract {
private:
    struct FE: public boost::msm::front::state_machine_def<FE> {


        /// FSM States:
        {% for state in model.fsm.states %}
        /// {{state.doc}}
        struct {{state.name}} : public boost::msm::front::state<> {};
        {% endfor %}

        using initial_state = {{model.fsm.initial}};

        /// The contract on order
        // clang-format off
        struct transition_table: boost::mpl::vector<
        {% for t in model.fsm.tt %}
            _row<{{"%12s"|format(t.ini.name)}}, {{"%12s"|format(t.evt)}}, {{"%12s"|format(t.fin.name)}}>{{"," if not loop.last}}
        {% endfor %}
        > {};
        // clang-format on

        /// MSM catches so we must rethrow
        template <class FSM,class Event>
        void exception_caught (Event const& evt, FSM&, std::exception& e)
        {
            throw dunedaq::appfwk::CommandContractViolation(
                ERS_HERE, "exception caught in FSM",
                CMD_FQNS::str(evt.command.id), "{{model.meta.name}}", e);
        }
    };
    using BE = boost::msm::back::state_machine<FE>;
    BE fsm;

public:
    using object_t = nlohmann::json;

    std::string name_;
    {{ccclass}}(std::string name) : dunedaq::appfwk::CommandContract(name), name_(name) {}
    virtual ~{{ccclass}}() {}

    virtual object_t validate(object_t cmdobj) {
        auto o = cmdobj.get<CMD_FQNS::Command>();
        std::string msg = "\n" + name_ + " validating: " + str(o.id) + "\n" + o.data.dump(4);
        ERS_INFO(msg);
        switch (o.id) {
            {% for evt in model.fsm.events %}
        case Id::{{"%-8s"|format(evt|lower)}}: fsm.process_event({{evt}}{o}); break;
        {% endfor %}
        default:
            throw dunedaq::appfwk::CommandContractViolation(
                ERS_HERE, "unknown command",
                CMD_FQNS::str(o.id), "{{model.meta.name}}");
            break;
        }
        // If we get here, the command is good.
        return cmdobj;
    }

};


extern "C" {
    std::shared_ptr<dunedaq::appfwk::CommandContract> make(std::string inst) { 
        return std::shared_ptr<dunedaq::appfwk::CommandContract>(new {{ccclass}}(inst));
    }
}
